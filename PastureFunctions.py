"""
author: Young

Pasture is the primary livestock feed source because in an extensive farming system it is a cost effective
source of energy that is available for the entire year. Different pasture types can be
represented by adding inputs for each pasture type. The default pasture type is “annual pasture”, however,
this can be changed by altering the inputs.

The pasture feed source can be supplemented with concentrates and in a mixed crop-livestock farm system
the pasture can be complemented with dry residues from crop production (stubbles).
The biology and logistics of pasture growth rate that are represented in AFO is:

    * PGR is dependent on pasture leaf area, which is quantified by the level of feed on offer (FOO, kg of DM/ha),
    * PGR for each pasture type varies with the phase during its life cycle, soil moisture and sunlight. All are quantified by land management unit, time of year and season.
    * The mobilisation of below ground reserves (germination) of annual pastures at the break of season is dependent on the seed bank. Seed bank is controlled by the rotation in which the pasture is grown.
    * The mobilisation of below ground reserves of perennial pastures at the break of season can also be adjusted by rotation, however, perennials ususally aren't grown in rotation with crops.
    * The digestibility of the diet selected by animals grazing pasture is dependent on their capacity for selective grazing which depends on FOO and grazing intensity.
    * The intake of animals grazing pasture is dependent on FOO and diet DMD.
    * The risk of resource degradation increases when ground cover is lower so there is a minimum limit to ground cover

The decision variables that can be optimised in AFO that represent the above biology are:

    * The rotation phases in which pasture can be grown on each LMU
    * A discrete range of FOO level (low, medium and high) at the start of each feed period
    * A discrete range of the severity of defoliation (0, 25%, 50% & 100%) in each feed period
    * The level of growth modifiers (nitrogen or gibberelic acid) applied to the pasture
    * The quantity of dry feed consumed from each of 2 dry feed quality groups in each feed period

Nutritive value of pasture is determined by the metabolisable energy per unit of dry matter, the relative
ingestibility and the relative availability. This varies with:

    1.	Feed period.
    2.	The level of FOO. The greater the FOO the lower the average digestibility of the sward. Lower digestibility
        of high FOO sward is associated with the lignification that occurs in older foliage, which is represented by
        a reduction in average digestibility associated with the number of days that the sward would need to be
        deferred to achieve the higher FOO.
        Higher digestibility of a low FOO sward is associated with the higher digestibility of new growth that
        constitutes a higher proportion of the sward. There can be some error associated with this assumption
        if the low FOO was generated by grazing a high FOO sward back to a low FOO, in which case most of the
        DM would be stalk at the base of the plant. Which compares to a sward that has been maintained at a
        low FOO level since the break of the season.
    3.	Grazing intensity. With heavy grazing there is little scope for selection so the diet digestibility equals the sward digestibility. With light grazing there is scope for selection and diet quality approaches that of high quality leaf. Note, increasing the energy content of the feed also improves the ingestibility of the feed.

Pasture is split into the following functions (see PastureFunctions):

    #.	Germination (f_germination)
    #.	Reseeding of pasture (f_reseeding)
    #.	Requirement for machinery for reseeding (f_pas_sow)
    #.	Green pasture: consumption, growth (f_grn_pasture)
    #.	Senescence of green pasture (f_senescence)
    #.	Dry pasture: consumption and decay (f_dry_pasture)
    #.	Pasture consumed on crop paddocks (f_poc)
    #.	Limit on grazing for soil conservation (f_erosion)

AFO can handle multiple pasture types. The user simply needs to create a copy of the inputs and calibrate them
to the new pasture.

"""


##import core modules
import numpy as np
import pandas as pd

##import AFO modules
import PropertyInputs as pinp
import UniversalInputs as uinp
import StructuralInputs as sinp
import Periods as per
import FeedsupplyFunctions as fsfun
import Functions as fun
import Sensitivity as sen


na = np.newaxis

def f_germination(i_germination_std_zt, i_germ_scalar_lzt, i_germ_scalar_p6zt
                  , pasture_rt, arable_l,  pastures, phase_germresow_df, i_phase_germ_dict, rt):
    '''
    Calculate mobilisation of the below ground reserves of the pasture for each rotation phase.

    For annual pastures the below ground reserves is the seed bank which is mobilised through germination. For
    perennial pastures it is the root reserves that are mobilised at the beginning of the growing season.

    The mobilisation is calculated for each pasture rotation phase based on the LMU and rotation history.
    The phase history is assumed only to impact pasture seed bank and hence pasture establishment. Phase
    history impacts the seed bank for three main reasons. Firstly, spraying out the weeds during the crop
    phase reduces seed set. Secondly, pasture manipulation in the prior years can reduce seed set. Thirdly,
    reseeding in the previous year can have carry forward benefits. For LMUs that have a component of
    non-arable area, the mobilisation on the arable area is affected by the phase history whereas the
    non-arable area are assumed to be the same as the continuous annual
    pasture rotation. Additionally, resown pastures or perennial pastures (e.g. Lucerne & Tedera)
    are only established on the arable areas, the non-arable areas are assumed to be growing annual pasture.

    :param i_germination_std_zt: standard germination level for the standard LMU in a continuous pasture rotation.
    :param i_germ_scalar_lzt: scalar for germination on each lmu.
    :param i_germ_scalar_p6zt: scalar for germination in each feed period.
    :param pasture_rt: Boolean array linking pasture type to rotation phase.
    :param arable_l: Proportion of arable land on each LMU.
    :param phase_germresow_df: array of rotation phases.
    :param i_phase_germ_dict: Dictionary with inputs of rotation germination for each pasture type.
    :return: pasture germination in each rotation phase.
    '''
    #todo currently all germination occurs in period 0, however, other code handles germination in other periods if the inputs & this code are changed
    germ_scalar_rt = np.zeros(rt,dtype = 'float64')
    for t, pasture in enumerate(pastures):
        phase_germresow_df['germ_scalar']=0 #set default to 0
        ###loop through each combo of landuses and pastures (i_phase_germ), then check which rotations fall into each germ category. Then populate the rot phase df with the necessary germination param.
        for ix_row in i_phase_germ_dict[pasture].index:
            ix_bool = pd.Series(data=True,index=range(len(phase_germresow_df)))
            for ix_col in range(i_phase_germ_dict[pasture].shape[1]-1):    #-1 because one of the cols is germ
                c_set = sinp.landuse[i_phase_germ_dict[pasture].iloc[ix_row,ix_col]]
                ix_bool &= phase_germresow_df.loc[:,ix_col].reset_index(drop=True).isin(c_set) #had to drop index so that it would work (just said false when the index was different between series)
            ### maps the relevant germ scalar and resown bool to the rotation phase
            phase_germresow_df.loc[list(ix_bool),'germ_scalar'] = i_phase_germ_dict[pasture].iloc[ix_row, -1]  #have to make bool into a list for some reason it doesn't like a series
        ### Convert germ and resow into a numpy - each pasture goes in a different slice
        germ_scalar_rt[:,t] = phase_germresow_df['germ_scalar'].to_numpy()    # extract the germ_scalar from the dataframe

    ## germination on the arable area of pasture paddocks based on std germ, rotation scalar, lmu scalar and distribution across periods
    arable_germination_p6lrzt = i_germination_std_zt                 \
                              *   i_germ_scalar_lzt[:, na, ...]     \
                              *      germ_scalar_rt[:, na, :]       \
                              *   i_germ_scalar_p6zt[:, na, na, ...]
    arable_germination_p6lrzt[np.isnan(arable_germination_p6lrzt)]  = 0.0

    ## germination on the non arable area is the maximum germination across phases (continuous pasture) for the first pasture type (annuals)
    ### todo a potential error here when if the allocation of germination across periods varies by rotation phase (because taking max of each period)
    max_germination_flzt = np.max(arable_germination_p6lrzt, axis=2)  #use germination_p6lrzt because it includes any sensitivity that is carried out

    ## germination on the non arable area of pasture paddocks. Grows pasture type 0 that can be grazed during the growing season
    na_germination_flrz = max_germination_flzt[..., na, :, 0] * np.any(pasture_rt[:, na, :], axis = -1)
    ## set germination in first period to germination on arable area
    germination_p6lrzt = arable_germination_p6lrzt * arable_l[:, na, na, na]
    ## add germination on the non-arable area to the first pasture type
    germination_p6lrzt[..., 0] += na_germination_flrz * (1 - arable_l[:,na,na])
    return germination_p6lrzt, max_germination_flzt

def f_reseeding(i_destock_date_zt, i_restock_date_zt, i_destock_foo_zt, i_restock_grn_propn_t, resown_rt
                , feed_period_dates_fz, i_restock_fooscalar_lt, i_restock_foo_arable_t, dry_decay_period_p6zt
                , i_fxg_foo_op6lzt, c_fxg_a_op6lzt, c_fxg_b_op6lzt, i_grn_senesce_eos_p6zt
                , grn_senesce_startfoo_p6zt, grn_senesce_pgrcons_p6zt, max_germination_flzt
                , length_fz, n_feed_periods, p6lrzt, p6zt, t_idx, z_idx, l_idx):
    '''
    Generates the green & dry FOO that is lost and gained from reseeding pasture.

    Resown pastures germinate as a usual pasture (see f_germination) the FOO is then set to 0 for the periods
    when the paddock is ungrazable due to reseeding. At the time of restocking the FOO on the arable areas
    is set based on user specified input and the FOO on the non-arable area is calculated from the FOO at
    destocking plus the growth over the destocked period. Pastures that are resown after the break of season
    can be grazed until user specified destocking date prior to reseeding. To give the resown pasture time
    to establish, the paddocks remain destocked until a user specified restock date.

    :param i_destock_date_zt: Date of destocking prior to reseeding.
    :param i_restock_date_zt: Date of restocking post reseeding.
    :param i_destock_foo_zt: Level of FOO at destocking prior to reseeding.
    :param i_restock_grn_propn_t: Proportion of the FOO that is green when pastures are restocked after reseeding.
    :param resown_rt: Boolean array denoting which rotations phases are resown.
    :param i_restock_fooscalar_lt: Scalar for FOO between LMUs when pastures are restocked after reseeding.
    :param i_restock_foo_arable_t: FOO at restocking on the arable area of the resown pastures.
    :param dry_decay_period_p6zt: decline in dry foo for each period.
    :param i_fxg_foo_op6lzt: each level of starting FOO used in conjunction with PGR.
    :param c_fxg_a_op6lzt: coefficient a for the FOO/growth/grazing variables. PGR = a + b FOO
    :param c_fxg_b_op6lzt: coefficient b for the FOO/growth/grazing variables. PGR = a + b FOO
    :param i_grn_senesce_eos_p6zt: proportion of green feed that senesces in period (due to a water deficit or completing life cycle).
    :param grn_senesce_startfoo_p6zt: proportion of start foo that senesces during the period (due to leaf drop).
    :param grn_senesce_pgrcons_p6zt: change of senescence over the period (due to growth and consumption).
    :param max_germination_flzt: maximum germination of annual pasture across all rotations.
    :return: Change in FOO due to reseeding pasture.
    '''
    #todo test the calculation of FOO on the resown area when the full set of rotation phases is included

    foo_grn_reseeding_p6lrzt     = np.zeros(p6lrzt,  dtype = 'float64')  # green FOO adjustment for destocking and restocking of the resown area (kg/ha)
    foo_dry_reseeding_p6lrzt     = np.zeros(p6lrzt,  dtype = 'float64')  # dry FOO adjustment for destocking and restocking of the resown area (kg/ha)
    foo_na_destock_p6zt = np.zeros(p6zt, dtype = 'float64')

    ## the green feed to remove from matrix when pasture is destocked (this is an input because we don't know how hard the paddock was grazed prior to reseeding so we just estimate the FOO level).
    foo_arable_destock_zt = i_destock_foo_zt
    foo_na_destock_zt =  i_destock_foo_zt
    ## the periods from which to remove foo based on date destocked. Returns feed period destocking occurs & the proportion of the way that destocking occurs.
    period_zt, proportion_zt = fun.period_proportion_np(feed_period_dates_fz[...,na]
                                                          , i_destock_date_zt)
    ## the change (reduction) in green and dry FOO on the arable and non-arable areas when pasture is destocked for spraying prior to reseeding
    ### the change in FOO on the nonarable area occurs in pasture type 0 (annuals) because it is assumed that other pasture species have not been established.
    ### Note: the arable proportion is accounted for in function
    foo_grn_reseeding_p6lrzt, foo_dry_reseeding_p6lrzt = f1_update_reseeding_foo(
        foo_grn_reseeding_p6lrzt, foo_dry_reseeding_p6lrzt, resown_rt, period_zt, 1 - proportion_zt, -foo_arable_destock_zt
        , - foo_na_destock_zt) # Assumes that all feed lost is green

    ##FOO on the arable area of each LMU when reseeded pasture is restocked (this is calculated from input values)
    foo_arable_restock_lt =  i_restock_fooscalar_lt * i_restock_foo_arable_t

    ## calc foo on non arable area when the area is restocked after reseeding
    ### FOO on non-arable areas at restocking equals foo at destocking plus any germination occurring in the destocked period plus growth from destocking to grazing
    #### FOO at destocking is an input, allocate the input to the destocking feed period
    foo_na_destock_p6zt[period_zt, z_idx[:,na], t_idx] = foo_na_destock_zt
    #### the period from destocking to restocking (for germination and growth)
    destock_duration_zt = i_restock_date_zt - i_destock_date_zt
    shape_p6zt = feed_period_dates_fz.shape + (i_destock_date_zt.shape[-1],)
    periods_destocked_p6zt = fun.f_range_allocation_np(feed_period_dates_fz[...,na], i_destock_date_zt, destock_duration_zt
                                                    , method=2, shape=shape_p6zt)[0:n_feed_periods,...]
    days_each_period_p6zt = periods_destocked_p6zt * length_fz[..., na]
    #### period when restocking occurs and the proportion through the period that it occurs
    period_zt, proportion_zt = fun.period_proportion_np(feed_period_dates_fz[...,na], i_restock_date_zt)

    ### germination during destocked period (this is the germination of pasture type 1 but it includes a t axis because the destocked period can vary with pasture type)
    germination_destocked_p6lzt = max_germination_flzt[...,0:1] * periods_destocked_p6zt[:, na, ...] #slice t for annual because annual pasture is on non-arable area

    ### Calculate the FOO profile on the non arable area from destocking through to restocking
    ### green FOO to start the profile is FOO at destocking plus germination that occurs during the destocking period
    #### assumes FOO at destocking of pasture type 0 on the non arable area is equivalent to the pasture itself.
    grn_foo_na_initial_p6lzt = foo_na_destock_p6zt[:, na, ...] + germination_destocked_p6lzt
    ####create temp arrays where all t slices have annual params (need to keep the t slices active for the next function so cant just slice the t)
    t_dry_decay_period_p6zt = np.zeros_like(dry_decay_period_p6zt)
    t_i_fxg_foo_op6lzt = np.zeros_like(i_fxg_foo_op6lzt)
    t_c_fxg_a_op6lzt = np.zeros_like(c_fxg_a_op6lzt)
    t_c_fxg_b_op6lzt = np.zeros_like(c_fxg_b_op6lzt)
    t_i_grn_senesce_eos_p6zt = np.zeros_like(i_grn_senesce_eos_p6zt)
    t_grn_senesce_startfoo_p6zt = np.zeros_like(grn_senesce_startfoo_p6zt)
    t_grn_senesce_pgrcons_p6zt = np.zeros_like(grn_senesce_pgrcons_p6zt)
    t_dry_decay_period_p6zt[...] = dry_decay_period_p6zt[..., 0:1]
    t_i_fxg_foo_op6lzt[...] = i_fxg_foo_op6lzt[..., 0:1]
    t_c_fxg_a_op6lzt[...] = c_fxg_a_op6lzt[..., 0:1]
    t_c_fxg_b_op6lzt[...] = c_fxg_b_op6lzt[..., 0:1]
    t_i_grn_senesce_eos_p6zt[...] = i_grn_senesce_eos_p6zt[..., 0:1]
    t_grn_senesce_startfoo_p6zt[...] = grn_senesce_startfoo_p6zt[..., 0:1]
    t_grn_senesce_pgrcons_p6zt[...] = grn_senesce_pgrcons_p6zt[..., 0:1]

    ###FOO at the end of the destocked period is calculated from the FOO profile from destocking to restocking
    #todo should these names should have na in them (because they are non arable)?
    grn_restock_foo_p6lzt, dry_restock_foo_p6lzt = f1_calc_foo_profile(grn_foo_na_initial_p6lzt  # axes are aligned in the function
                                                                     , t_dry_decay_period_p6zt
                                                                     , days_each_period_p6zt
                                                                     , t_i_fxg_foo_op6lzt
                                                                     , t_c_fxg_a_op6lzt
                                                                     , t_c_fxg_b_op6lzt
                                                                     , t_i_grn_senesce_eos_p6zt
                                                                     , t_grn_senesce_startfoo_p6zt
                                                                     , t_grn_senesce_pgrcons_p6zt)

    ### combine dry and grn foo because the proportion of green at restocking is an input
    #### foo is calculated at the start of period, +1 to get end period FOO.
    foo_na_restock_lzt = grn_restock_foo_p6lzt[period_zt+1,l_idx[:,na,na], z_idx[:,na], t_idx]   \
                        + dry_restock_foo_p6lzt[period_zt+1,l_idx[:,na,na], z_idx[:,na], t_idx] #foo is calc at the start of period, +1 to get end period foo.

    ## increment the change in green and dry foo on the arable and non-arable areas when pasture is restocked after reseeding
    ### Note: the function call includes += for the green and dry foo variables

    ## combine the non-arable and arable foo to get the resulting foo in the green and dry pools when paddocks are restocked. Spread between periods based on date grazed. (arable proportion accounted for in function)
    ### the change in FOO on the nonarable area occurs in pasture type 0 (annuals) because it is assumed that other pasture species have not been established.
    ### Note: the arable proportion is accounted for in function
    foo_grn_reseeding_p6lrzt, foo_dry_reseeding_p6lrzt = f1_update_reseeding_foo(foo_grn_reseeding_p6lrzt  #axes aligned in function
                                                                               , foo_dry_reseeding_p6lrzt
                                                                               ,                 resown_rt
                                                                               ,               period_zt
                                                                               ,       1 - proportion_zt
                                                                               ,   foo_arable_restock_lt[:,na,:]
                                                                               ,       foo_na_restock_lzt
                                                                               , propn_grn=i_restock_grn_propn_t)

    ## split the change in dry FOO between the high & low quality FOO pools
    ### a 50% split assumes the dry feed removed at destocking and added at restocking is average quality.
    foo_dry_reseeding_dp6lrzt = np.stack([foo_dry_reseeding_p6lrzt * 0.5, foo_dry_reseeding_p6lrzt * 0.5], axis=0)
    return foo_grn_reseeding_p6lrzt, foo_dry_reseeding_dp6lrzt, periods_destocked_p6zt


# def f_pas_sow(i_reseeding_date_start_zt, i_reseeding_date_end_zt, resown_rt, arable_l, phases_rotn_df, pastures):
#     '''
#     Calculate the sowing provided by the pas_sow activity in each machinery period for each pasture landuse.
#
#     The sow activity only provides seeding during the machinery periods that align with reseeding date and only provides
#     sowing for the resown pasture landuses.
#
#     :param i_reseeding_date_start_zt: Date reseeding begins.
#     :param i_reseeding_date_end_zt: Date reseeding ends.
#     :param resown_rt: Boolean array denoting which rotations phases are resown.
#     :param arable_l: Proportion of arable land on each LMU.
#     :return: Pasture sowing requirement for all rotation phases.
#     '''
#     ### sow param determination
#     ### determine the labour periods pas seeding occurs
#     labour_period_p5z = per.f_p_dates_df()
#     labour_period_start_p5z = labour_period_p5z.values[:-1]
#     labour_period_end_p5z = labour_period_p5z.values[1:]
#     period_is_passeeding_p5zt = (labour_period_start_p5z[:,:,na] < i_reseeding_date_end_zt) * (labour_period_end_p5z[:,:,na] > i_reseeding_date_start_zt)
#
#     ## add k (landuse axis) - this is required for sow param
#     keys_k = np.asarray(list(sinp.landuse['All']))
#     kt = (len(keys_k), len(pastures))
#     seeding_landuses = uinp.mach[pinp.mach['option']]['seeder_speed_crop_adj'].index
#     resown_kt = np.zeros(kt)
#     for t,pasture in enumerate(pastures):
#         pasture_landuses = list(sinp.landuse['pasture_sets'][pasture])
#         resown_kt[:,t] = np.logical_and(np.in1d(keys_k, seeding_landuses), np.in1d(keys_k, pasture_landuses)) #resown if landuse is a pasture and is a sown landuse
#     pas_sow_prov_pkz = np.sum(resown_kt[:,na,:] * period_is_passeeding_p5zt[:,na,...], -1) #sum t axis - t is counted for in the k axis
#     return pas_sow_prov_pkz


def f1_green_area(resown_rt, pasture_rt, periods_destocked_p6zt, arable_l, i_pasture_coverage_lt):
    ## area of green pasture being grazed and growing
    ### calculate the area (for all the phases) that is growing pasture for each feed period. The area can be 0 for a pasture phase if it has been destocked for reseeding.
    arable_phase_area_p6lrzt = (1 - (resown_rt[:,na,:] * periods_destocked_p6zt[:, na, na, ...]))  \
                             * arable_l[:, na, na, na] * pasture_rt[:, na, :] * i_pasture_coverage_lt[:,na,na,:]
    phase_area_p6lrzt = arable_phase_area_p6lrzt
    ###pasture on the non-arable area is annual pasture only (first pasture type 0:1)
    #### Note: the area of rocks and trees are excluded from total area so pasture coverage on NA areas is 100%
    na_phase_area_p6lrzt = np.sum((1 - (resown_rt[:,na,:] * periods_destocked_p6zt[:, na, na, ...]))
                                        * (1 - arable_l[:, na, na, na]) * pasture_rt[:, na, :]
                                        # * i_pasture_coverage_lt[:,na,na,0:1]
                                        , axis = -1, keepdims=True)
    phase_area_p6lrzt[..., 0:1] = phase_area_p6lrzt[..., 0:1] + na_phase_area_p6lrzt
    return phase_area_p6lrzt


def f_erosion(i_lmu_conservation_p6lzt, arable_l, pasture_rt):
    '''
    The minimum FOO at the end of each period.

    Due to sustainability bare paddocks are often avoided by farmers. To represent this in the model pasture
    paddocks have user defined erosion limit which specifies how much FOO must still cover the paddocks in the
    following year. This stops the model consuming all the dry feed and leaving the paddocks bare and exposed
    to wind erosion.

    :param i_lmu_conservation_p6lzt: Minimum foo at end of each period to reduce risk of wind & water erosion.
    :param arable_l: Proportion of arable land on each LMU.
    :param pasture_rt: Boolean array linking pasture type to rotation phase.
    :return: The minimum FOO at the end of each period for each rotation phase.
    '''
    arable_erosion_p6lrzt = i_lmu_conservation_p6lzt[..., na,:,:]  \
                                    *  arable_l[:, na, na, na]  \
                                    * pasture_rt[:,na,:]
    na_erosion_p6lrz = np.sum(i_lmu_conservation_p6lzt[..., na,:,:]
                                    *         (1-arable_l[:, na, na, na])
                                    *           pasture_rt[:,na,:]
                                    , axis = -1)
    erosion_p6lrzt = arable_erosion_p6lrzt
    erosion_p6lrzt[..., 0] = erosion_p6lrzt[..., 0] + na_erosion_p6lrz #non arable area is annual pasture thus add to the annual slice
    return erosion_p6lrzt


def f_grn_pasture(cu3, cu4, i_fxg_foo_op6lzt, i_fxg_pgr_op6lzt, c_pgr_gi_scalar_gp6zt, grn_foo_start_ungrazed_p6lzt
                  , i_foo_graze_propn_gt, grn_senesce_startfoo_p6zt, grn_senesce_pgrcons_p6zt, i_grn_senesce_eos_p6zt
                  , i_base_p6zt, i_grn_trampling_ft, i_grn_dig_p6lzt, i_grn_dmd_range_p6zt, i_pasture_stage_p6zt
                  , i_legume_zt, i_hr_scalar_zt, me_threshold_fp6zt, i_me_eff_gainlose_p6zt, mask_greenfeed_exists_p6zt
                  , length_fz, nv_is_not_confinement_f):
    '''
    Pasture growth, consumption and senescence of green feed.

    The green pasture decision variables combine the representation of FOO at the start of the period, FOO at the
    end of the period, animal removal, energy per unit of dry matter and volume. Aggregating the decision variable
    to include all these factors allows representation (and optimisation) of:

        #. The intake capacity of livestock is affected by the level of FOO at the start of the period & level of grazing
           intensity. Both affect average FOO which controls the intake by stock. When there is more FOO, animals can
           eat more and achieve higher growth rates.

        #. Livestock diet quality change with grazing pressure (eg. by running a lower stocking rate livestock can
           improve their diet quality through increased diet selectivity). This selectivity can be important for
           finishing animals for market or fattening animals for mating.

        #. The digestibility of pasture decreases as the length of time from the last defoliation increases (i.e. older
           leaves are less digestible). Having consumption and FOO in the same activity allows a drop in digestibility
           associated with old leaf to be included by linking digestibility to FOO. This is especially important for
           species such as kikuyu that drop in digestibility rapidly if pastures are grazed laxly and FOO increases.

        #. The pasture growth is reduced with higher grazing intensity because the average leaf area is reduced
           during the growth period.

    These issues are likely more important in a system producing meat, where growth rate of animals and hence
    diet quality is critical to profitability. In a meat system the trade-off between quantity of feed utilised
    and quality of feed is quite different than the trade-off for a wool system.

    For a given period, the decision variables are defined by starting FOO level and grazing intensity. There
    are three foo levels; low, medium and high starting FOO and four grazing intensities; no grazing, low,
    medium and high. Green pasture decision variables represent the total green pasture on the farm in each
    period. The level of the decision variables at the start of the growing season are determined by the area
    of pasture and its level of establishment (see f_germination).

    Gross pasture growth rate for each activity is calculated as a linear interpolation of the inputs of PGR
    by FOO using the input FOO level for the growth/consumption activity and grazing intensity during a period
    reduces growth rate during the period.

    Diet digestibility is the overall quality of the pasture consumed by the livestock. The input value is the
    quality of the high quality component of the sward when animals have capacity to graze selectively
    (25% grazing intensity). At higher grazing intensity the reduction in diet quality depends on the (input)
    range of digestibility within the sward. The reduction in digestibility for the 100% grazing intensity
    decision variable is half the range of digestibility within the sward. If the nutritive value of the feed
    is greater than the livestock's requirement the quality is reduced by a given factor (see fsfun.f_effective_mei).

    When the pasture senesces, it is removed from the green pasture pool and allocated into the dry pasture pool.
    The calculation of senescence is done in 2 parts. The first part relates to the older leaves of the plant
    senescing in the process of new growth. This is calculated as a proportion of the average FOO in the period.
    Thus, it varies depending on new growth and grazing. The second part of senescence is the death of the whole
    plant at the end of the reproductive cycle or in response to water deficit (termed end-of-season senescence).
    It is modelled to occur at the end of the specified period and the user specified proportion of FOO prior to
    end-of-season senescence is passed into the dry feed pool.


    :param cu3: params used to convert foo for rel availability.
    :param cu4: params used to convert height for rel availability.
    :param i_fxg_foo_op6lzt: each level of starting FOO used in conjunction with PGR.
    :param i_fxg_pgr_op6lzt: PGR at each level of starting FOO if the pasture is not grazed for each soil type (typically derived from a simulation model).
    :param c_pgr_gi_scalar_gp6zt: The impact of grazing intensity within the period on the PGR achieved.
    :param grn_foo_start_ungrazed_p6lzt:  FOO at the start of the period if the pasture has been ungrazed from the start of the growing season.
    :param i_foo_graze_propn_gt: proportion of the FOO available (greater than the base level) that is grazed for each level of grazing intensity.
    :param grn_senesce_startfoo_p6zt: The proportion of the green feed at the start of the period that senesces.
    :param grn_senesce_pgrcons_p6zt: The proportion of the green feed that grows during the period that senesces (or the reduction in senescence if FOO reduces due to grazing).
    :param i_grn_senesce_eos_p6zt: The proportion of the green feed at the end of the period that senesces because it is the end of the growing season.
    :param i_base_p6zt: The base FOO level which represents the level below which the pasture can’t be grazed. This base
                      level is set with several criteria in mind; the physical limit at which animals can graze, an
                      erosion limit below which farmers wouldn't or shouldn't graze; the optimum level of FOO based on
                      the trade-off between PGR and FOO.
    :param i_grn_trampling_ft: amount of feed that is trampled while green feed is being consumed as a proportion of the feed consumed.
    :param i_grn_dig_p6lzt: DMD of the green feed that would be consumed if animals graze with 25% grazing intensity a sward that has medium FOO level in each feed period on each LMU.
    :param i_grn_dmd_range_p6zt: Range of DMDin the sward between the 25th percentile to the 75th percentile.
    :param i_pasture_stage_p6zt: Maturity of the pasture (establishment or vegetative as defined by CSIRO)
    :param i_legume_zt: Legume content of pasture.
    :param i_hr_scalar_zt: Scalar for the height ratio of this pasture.
    :param me_threshold_fp6zt: The nutritive value above which scaling will occur for the NV pool.
    :param i_me_eff_gainlose_p6zt: Reduction in efficiency if M/D is above requirement for target LW pattern.
    :param mask_greenfeed_exists_p6zt: Boolean array stating which periods dry pasture exists.
    :param nv_is_not_confinement_f: boolean array stating which nv pools are not confinement feeding pools.
    :return: Quantity and quality of green pasture.
    '''
    #todo review the research data to decide if trampling is more closely related to FOO or consumption (currently represented as a propn of feed consumed).

    ## green initial FOO for the 'grnha' decision variables
    foo_start_grnha_op6lzt = i_fxg_foo_op6lzt
    #    foo_start_grnha_op6lzt = np.maximum(i_fxg_foo_op6lzt, i_base_ft[:, na, na, :])  # to ensure that final foo can not be below the base level
    #FOO of the high FOO slice is the maximum of ungrazed foo and foo from the medium foo level
    max_foo_p6lzt = np.maximum(i_fxg_foo_op6lzt[1, ...], grn_foo_start_ungrazed_p6lzt)
    #maximum accumulated along the feed periods axis, i.e. max to date
    foo_start_grnha_op6lzt[2, ...] = np.maximum.accumulate(max_foo_p6lzt, axis=0)
    #masks out any green foo at the end of periods in which green pasture doesn't exist.
    foo_start_grnha_op6lzt = foo_start_grnha_op6lzt * mask_greenfeed_exists_p6zt[:, na,...]

    ## green, pasture growth for the 'grnha' decision variables
    #todo revisit the effect of gi on PGR by basing the reduction on the effect of gi on average FOO (rather than c_pgr_gi_scalar)
    pgr_grnha_gop6lzt = (i_fxg_pgr_op6lzt * length_fz[:, na, :, na]
                        * c_pgr_gi_scalar_gp6zt[:, na, :, na, :, :] * mask_greenfeed_exists_p6zt[:, na, ...])

    ## green, final foo from initial, pgr and senescence
    ### senescence during the period is senescence of the starting FOO and of the FOO that is added/reduced by growth/grazing
    senesce_period_grnha_gop6lzt = (foo_start_grnha_op6lzt * grn_senesce_startfoo_p6zt[:, na, ...]
                                   + pgr_grnha_gop6lzt * grn_senesce_pgrcons_p6zt[:, na, ...])
    ### foo at end of period if ungrazed
    foo_end_ungrazed_grnha_op6lzt = foo_start_grnha_op6lzt + pgr_grnha_gop6lzt[0, ...] - senesce_period_grnha_gop6lzt[0, ...]
    ### foo at end of period with range of grazing intensity prior to eos senescence
    foo_endprior_grnha_gop6lzt = (foo_end_ungrazed_grnha_op6lzt
                                 - (foo_end_ungrazed_grnha_op6lzt - i_base_p6zt[:, na, :, :])
                                 * i_foo_graze_propn_gt[:, na, na, na, na, :])
    senesce_eos_grnha_gop6lzt = foo_endprior_grnha_gop6lzt * i_grn_senesce_eos_p6zt[:, na, ...]
    foo_end_grnha_gop6lzt = foo_endprior_grnha_gop6lzt - senesce_eos_grnha_gop6lzt
    #apply mask to remove any green foo at the end of period in periods when green pas doesn't exist.
    foo_end_grnha_gop6lzt = foo_end_grnha_gop6lzt * mask_greenfeed_exists_p6zt[:, na, ...]

    ## green, removal & dmi
    ### divide by (1 - grn_senesce_pgrcons) to allows for consuming feed reducing senescence
    removal_grnha_gop6lzt = np.maximum(0, fun.f_divide((foo_start_grnha_op6lzt * (1 - grn_senesce_startfoo_p6zt[:, na, ...])
                                                        + pgr_grnha_gop6lzt * (1 - grn_senesce_pgrcons_p6zt[:, na, :])
                                                        - foo_endprior_grnha_gop6lzt)
                                                       , (1 - grn_senesce_pgrcons_p6zt[:, na, :])))
    cons_grnha_gop6lzt = removal_grnha_gop6lzt / (1 + i_grn_trampling_ft[:, na, na, :])

    ## green, dmd & md from input values and impact of foo & grazing intensity
    ### sward digestibility is reduced with higher FOO (based on start FOO)
    ### diet digestibility is reduced with higher FOO if grazing intensity is greater than 25%
    #### Low FOO or low grazing intensity is input
    #### High FOO with 100% grazing is reduced by half the range in digestibility.
    #### Between low and high FOO it is a linear interpolation
    dmd_sward_start_grnha_op6lzt = (i_grn_dig_p6lzt - i_grn_dmd_range_p6zt[:, na, :, :] / 2
                                   * fun.f_divide(foo_start_grnha_op6lzt - foo_start_grnha_op6lzt[0, ...]
                                                  , foo_start_grnha_op6lzt[-1, ...] - foo_start_grnha_op6lzt[0, ...]))
    #### Diet digestibility includes a linear interpolation of selectivity
    #### 0.25 is grazing intensity that gives diet quality == input value.
    dmd_diet_grnha_gop6lzt = (i_grn_dig_p6lzt - i_grn_dmd_range_p6zt[:, na, :, :] / 2
                             * fun.f_divide(foo_start_grnha_op6lzt - foo_start_grnha_op6lzt[0, ...]
                                            , foo_start_grnha_op6lzt[-1, ...] - foo_start_grnha_op6lzt[0, ...])
                             * (i_foo_graze_propn_gt[:, na, na, na, na, :] - 0.25) / (1 - 0.25))
    #### dmd of the sward after grazing is reduced due to removal of the high quality feed from selective grazing
    dmd_sward_end_grnha_gop6lzt = dmd_sward_start_grnha_op6lzt - ((dmd_diet_grnha_gop6lzt - dmd_sward_start_grnha_op6lzt)
                                                                * fun.f_divide(i_foo_graze_propn_gt[:, na, na, na, na, :]
                                                                    , 1 - i_foo_graze_propn_gt[:, na, na, na, na, :]))
    grn_md_grnha_gop6lzt = fsfun.f1_dmd_to_md(dmd_diet_grnha_gop6lzt)

    ## green, mei & volume
    ###Average FOO is calculated using FOO at the end prior to EOS senescence (which assumes all pasture senesces after grazing)
    foo_ave_grnha_gop6lzt = (foo_start_grnha_op6lzt + foo_endprior_grnha_gop6lzt) / 2
    ### pasture params used to convert foo for rel availability
    pasture_stage_p6lzt = i_pasture_stage_p6zt[:, na, :, :]
    ### adjust foo and calc hf
    foo_ave_grnha_gop6lzt, hf = fsfun.f_foo_convert(cu3, cu4, foo_ave_grnha_gop6lzt, pasture_stage_p6lzt
                                                    , i_legume_zt, i_hr_scalar_zt, z_pos=-2)
    ### calc relative availability - note that the equation system used is the one selected for dams in p1
    if uinp.sheep['i_eqn_used_g1_q1p7'][5, 0] == 0:  #csiro function used
        grn_ri_availability_gop6lzt = fsfun.f_ra_cs(foo_ave_grnha_gop6lzt, hf)
    elif uinp.sheep['i_eqn_used_g1_q1p7'][5, 0] == 1:  #Murdoch function used
        grn_ri_availability_gop6lzt = fsfun.f_ra_mu(foo_ave_grnha_gop6lzt, hf)
    ### calc relative quality - note that the equation system used is the one selected for dams in p1 - currently only cs function exists
    if uinp.sheep['i_eqn_used_g1_q1p7'][6, 0] == 0:  #csiro function used
        grn_ri_quality_gop6lzt = fsfun.f_rq_cs(dmd_diet_grnha_gop6lzt, i_legume_zt)
    grn_ri_gop6lzt = fsfun.f_rel_intake(grn_ri_availability_gop6lzt, grn_ri_quality_gop6lzt, i_legume_zt)

    ###reduce me if nv is above diet requirement
    confinement_inc = np.any(np.logical_not(nv_is_not_confinement_f))
    me_cons_grnha_fgop6lzt = fsfun.f_effective_mei(cons_grnha_gop6lzt, grn_md_grnha_gop6lzt
                                                  , me_threshold_fp6zt[:, na, na, :, na, ...], confinement_inc
                                                  , grn_ri_gop6lzt, i_me_eff_gainlose_p6zt[:, na, :, :])
    #apply mask - this masks out any green foo at the end of period in periods when green pas doesn't exist.
    me_cons_grnha_fgop6lzt = me_cons_grnha_fgop6lzt * mask_greenfeed_exists_p6zt[:, na, ...]
    ## Pasture can't be grazed in confinement so ME is 0
    me_cons_grnha_fgop6lzt = me_cons_grnha_fgop6lzt * nv_is_not_confinement_f[:, na, na, na, na, na, na]

    # parameters for the growth/grazing activities: Total volume of feed consumed from the hectare
    volume_grnha_gop6lzt = cons_grnha_gop6lzt / grn_ri_gop6lzt
    #apply mask - this masks out any green foo at the end of period in periods when green pas doesn't exist.
    volume_grnha_gop6lzt = volume_grnha_gop6lzt * mask_greenfeed_exists_p6zt[:, na,...]
    #me from pasture is 0 in the confinement pool
    volume_grnha_fgop6lzt = volume_grnha_gop6lzt * nv_is_not_confinement_f[:, na, na, na, na, na, na]

    ##convert to tonnes
    cons_grnha_t_gop6lzt = cons_grnha_gop6lzt/1000
    return (me_cons_grnha_fgop6lzt, volume_grnha_fgop6lzt, foo_start_grnha_op6lzt, foo_end_grnha_gop6lzt
           , senesce_period_grnha_gop6lzt, senesce_eos_grnha_gop6lzt, dmd_sward_end_grnha_gop6lzt, pgr_grnha_gop6lzt
           , foo_endprior_grnha_gop6lzt, cons_grnha_t_gop6lzt, foo_ave_grnha_gop6lzt, dmd_diet_grnha_gop6lzt)


def f1_senescence(senesce_period_grnha_gop6lzt, senesce_eos_grnha_gop6lzt, dry_decay_period_p6zt, dmd_sward_end_grnha_gop6lzt
                 , i_grn_dmd_senesce_redn_p6zt, dry_dmd_dp6zt, mask_greenfeed_exists_p6zt):
    '''
    Combines the components of senescence and allocates to the dry pasture pools.

    The proportion of senesced pasture that enters the high and low quality dry pasture pool is calculated based
    on the range of quality in the senescing green feed.

    :param senesce_period_grnha_gop6lzt: senescence of green pasture during the period.
    :param senesce_eos_grnha_gop6lzt: end of season senescence of green pasture.
    :param dry_decay_period_p6zt: decline in dry foo for each period.
    :param dmd_sward_end_grnha_gop6lzt: dmd of the sward after grazing is reduced due to removal of the high quality feed from selective grazing.
    :param i_grn_dmd_senesce_redn_p6zt: reduction in digestibility of green feed when it senesces
    :param dry_dmd_dp6zt: digestibility of each dry pasture pool.
    :param mask_greenfeed_exists_p6zt: Boolean array stating which periods dry pasture exists.
    :return: Amount of pasture that senesces into each dry pasture pool each feed period.
    '''
    ## senescence from green to dry - green, total senescence for the period (available in the next period)
    ## the pasture that senesces at the eos is assumed to be senescing at the end of the growth period and doesn't decay
    ## the pasture that senesces during the period decays prior to being transferred
    ## the senesced feed that is available to stock is that which senesces at the end of the growing season (i.e. not during the growing season)
    senesce_total_grnha_gop6lzt = senesce_eos_grnha_gop6lzt + senesce_period_grnha_gop6lzt * (1 - dry_decay_period_p6zt[:, na, ...])
    grn_dmd_senesce_gop6lzt = dmd_sward_end_grnha_gop6lzt + i_grn_dmd_senesce_redn_p6zt[:, na, ...]
    # senescence to high pool. np.clip reduces the range of the dmd to the range of dmd in the dry feed pools
    senesce_propn_h_gop6lzt = np.clip((grn_dmd_senesce_gop6lzt - dry_dmd_dp6zt[0,:, na, :])
                                      / (dry_dmd_dp6zt[1,:, na,:] - dry_dmd_dp6zt[0,:, na,:]), 0, 1)
    senesce_propn_l_dgop6lzt = 1- senesce_propn_h_gop6lzt                       # senescence to low pool
    senesce_propn_dgop6lzt = np.stack([senesce_propn_l_dgop6lzt, senesce_propn_h_gop6lzt])
    senesce_grnha_dgop6lzt = senesce_total_grnha_gop6lzt * senesce_propn_dgop6lzt       # ^alternative in one array parameters for the growth/grazing activities: quantity of green that senesces to the high pool
    senesce_grnha_dgop6lzt = senesce_grnha_dgop6lzt * mask_greenfeed_exists_p6zt[:, na, ...]  # apply mask - green pasture only senesces when green pas exists.
    return senesce_grnha_dgop6lzt


def f_dry_pasture(cu3, cu4, i_dry_dmd_ave_p6zt, i_dry_dmd_range_p6zt, i_dry_foo_high_p6zt, me_threshold_fp6zt, i_me_eff_gainlose_p6zt, mask_dryfeed_exists_p6zt
                  , i_pasture_stage_p6zt, nv_is_not_confinement_f, i_legume_zt, i_hr_scalar_zt, n_feed_pools):
    '''
    Calculate the quality and quantity of dry pasture available throughout the year.

    Dry pasture is represented by a low- and high-quality decision variable. When green feed senesces a proportion
    of the feed enters each pool based on the digestibility of the senescing feed. This representation allows some
    diet selection to occur, with the higher quality component grazed by different sheep than the lower quality.
    The ‘high’ pool has digestibility of the 25th percentile and the ‘low’ group the 75th percentile. If the nutritive
    value of the feed is greater than the livestock's requirement the quality is reduced by a given factor (see fsfun.f_effective_mei).

    Non arable area on crop paddocks grow pasture all season, calculated as an ungrazed green annual pasture
    (see f_grn_pas). After harvest pasture on non-arable areas can be consumed. All pasture grown on the
    non-arable area of crop paddock is allocated to the low-quality dry pasture pool because it has grown
    all year without being grazed.

    Dry pasture that is not consumed is passed to the same pool in the next period and the average quality
    and quantity reduces each period as it decays. Dry pasture does not transfer into the new season because once green
    feed is available stock will not graze old dry feed. Consumption of the high quality/high FOO component further
    reduces the average as the feed available skews towards the low-quality pool.

    .. note:: There is not a constraint that ensures that the high-quality pasture pool is grazed prior to the
        low-quality pool (unlike the grazing of stubbles where it does exist).

    :param cu3: params used to convert foo for rel availability.
    :param cu4: params used to convert height for rel availability.
    :param i_dry_dmd_ave_p6zt: average digestibility of dry feed. Note the reduction in this value determines the
                              reduction in quality of ungrazed dry feed in each of the dry feed quality pools. The
                              average digestibility of the dry feed sward will depend on selective grazing which
                              is an optimised variable.
    :param i_dry_dmd_range_p6zt: range in digestibility of dry feed if it is not grazed.
    :param i_dry_foo_high_p6zt: expected foo for the dry pasture in the high quality pool.
    :param me_threshold_fp6zt: the nutritive value above which scaling will occur for the NV pool.
    :param i_me_eff_gainlose_p6zt: Reduction in efficiency if M/D is above requirement for target LW pattern
    :param mask_dryfeed_exists_p6zt: Boolean array stating which periods dry pasture exists.
    :param i_pasture_stage_p6zt: maturity of the pasture (establishment or vegetative as defined by CSIRO)
    :param nv_is_not_confinement_f: boolean array stating which nv pools are not confinement feeding pools.
    :param i_legume_zt: legume content of pasture.
    :param i_hr_scalar_zt: Scalar for height of the pasture
    :return: Quantity and quality of dry pasture.
    '''
    #Consumption & deferment of dry feed.
    ## dry, dmd & foo of feed consumed
    dry_dmd_high_p6zt = i_dry_dmd_ave_p6zt + i_dry_dmd_range_p6zt/2
    dry_dmd_low_p6zt  = i_dry_dmd_ave_p6zt - i_dry_dmd_range_p6zt/2
    dry_dmd_dp6zt     = np.stack((dry_dmd_low_p6zt, dry_dmd_high_p6zt), axis=0)    # create an array with a new axis 0 by stacking the existing arrays

    dry_foo_high_p6zt = i_dry_foo_high_p6zt * 3/4
    dry_foo_low_p6zt  = i_dry_foo_high_p6zt * 1/4                               # assuming half the foo is high quality and the remainder is low quality
    dry_foo_dp6zt     = np.stack((dry_foo_low_p6zt, dry_foo_high_p6zt),axis=0)  # create an array with a new axis 0 by stacking the existing arrays

    ## dry, volume of feed consumed per tonne
    ### adjust foo and calc hf
    pasture_stage_p6zt = i_pasture_stage_p6zt
    dry_foo_dp6zt, hf = fsfun.f_foo_convert(cu3, cu4, dry_foo_dp6zt, pasture_stage_p6zt, i_legume_zt
                                            , i_hr_scalar_zt, z_pos=-2)
    ### calc relative availability - note that the equation system used is the one selected for dams in p=0
    if uinp.sheep['i_eqn_used_g1_q1p7'][5,0]==0: #csiro function used
        dry_ri_availability_dp6zt = fsfun.f_ra_cs(dry_foo_dp6zt, hf)
    elif uinp.sheep['i_eqn_used_g1_q1p7'][5,0]==1: #Murdoch function used
        dry_ri_availability_dp6zt = fsfun.f_ra_mu(dry_foo_dp6zt, hf)

    ### calc relative quality - note that the equation system used is the one selected for dams in p1 - currently only cs function exists
    if uinp.sheep['i_eqn_used_g1_q1p7'][6,0]==0: #csiro function used
        dry_ri_quality_dp6zt = fsfun.f_rq_cs(dry_dmd_dp6zt, i_legume_zt)
    dry_ri_dp6zt = fsfun.f_rel_intake(dry_ri_availability_dp6zt, dry_ri_quality_dp6zt, i_legume_zt)  #set the minimum RI to 0.05

    dry_volume_t_dp6zt = 1000 / dry_ri_dp6zt                 # parameters for the dry feed grazing activities: Total volume of the tonne consumed
    dry_volume_t_dp6zt = dry_volume_t_dp6zt * mask_dryfeed_exists_p6zt  #apply mask - this masks out any green foo at the end of period in periods when green pas doesn't exist.
    dry_volume_t_fdp6zt = dry_volume_t_dp6zt * nv_is_not_confinement_f[:,na,na,na,na] #me from pasture is 0 in the confinement pool

    ## dry, ME consumed per kg consumed
    dry_md_dp6zt        = fsfun.f1_dmd_to_md(dry_dmd_dp6zt)
    ## convert to effective quality per tonne
    ### parameters for the dry feed grazing activities: Total ME of the tonne consumed
    confinement_inc = np.any(np.logical_not(nv_is_not_confinement_f))
    dry_mecons_t_fdp6zt = fsfun.f_effective_mei( 1000, dry_md_dp6zt, me_threshold_fp6zt[:, na, ...]
                                                , confinement_inc, dry_ri_dp6zt, i_me_eff_gainlose_p6zt)
    dry_mecons_t_fdp6zt = dry_mecons_t_fdp6zt * mask_dryfeed_exists_p6zt  #apply mask - this masks out consuming dry foo in periods when dry pas doesn't exist.
    #Can't graze dry pasture while in confinement so ME is 0
    dry_mecons_t_fdp6zt = dry_mecons_t_fdp6zt * nv_is_not_confinement_f[:,na,na,na,na]
    return dry_mecons_t_fdp6zt, dry_volume_t_fdp6zt, dry_dmd_dp6zt, dry_foo_dp6zt


def f_poc(cu3, cu4, i_poc_intake_daily_p6lzt, i_poc_dmd_p6zt, i_poc_foo_p6zt, i_legume_zt, i_hr_scalar_zt
          , i_pasture_stage_p6zt, nv_is_not_confinement_f, me_threshold_fp6zt, i_me_eff_gainlose_p6zt):
    '''
    Calculate energy, volume and consumption parameters for pasture consumed on crop paddocks before seeding.

    The amount of pasture consumption that can occur on crop paddocks per hectare per day before seeding
    - adjusted for lmu and feed period
    The energy provided by the consumption of 1 tonne of pasture on crop paddocks.
    - adjusted for feed period
    The livestock intake volume required to consume 1 tonne of pasture on crop paddocks.
    - adjusted for feed period

    Pasture can be grazed on crop paddocks if seeding occurs after pasture germination. Grazing can occur between
    pasture germination and destocking. Destocking date occurs a certain number of days before seeding, this is to
    allow the pasture leaf area to grow so that the knock down spray is effective. The amount of pasture that can be
    consumed per day is a user defined input that can vary by LMU. The grazing days provide by each seeding activity
    are calculated in mach.py and depend on the time between the break of season and destocking prior to seeding.

    The main assumption/limitation of the poc representation is that the pasture consumption per lmu per day per ha
    is a fixed value per feed period. This means grazing management of POC isn't optimised.

    :param cu3: params used to convert foo for rel availability.
    :param cu4: params used to convert height for rel availability.
    :param i_poc_intake_daily_p6lzt: maximum daily intake available from 1ha of pasture on crop paddocks
    :param i_poc_dmd_p6zt: average digestibility of pasture on crop paddocks.
    :param i_poc_foo_p6zt: average foo of pasture on crop paddocks.
    :param i_legume_zt: legume content of pasture.
    :param i_hr_scalar_zt: Scalar for the height of the pasture
    :param i_pasture_stage_p6zt: maturity of the pasture (establishment or vegetative as defined by CSIRO)
    :param nv_is_not_confinement_f: boolean array stating which nv pools are not confinement feeding pools.
    :return:
        - poc_con_fl - tonnes of dry matter available per hectare per day on crop paddocks before seeding.
        - poc_md_fp6 - md per tonne of poc.
        - poc_vol_fz - volume required to consume 1 tonne of poc.
    '''
    ### poc is assumed to be annual hence the 0 slice in the last axis
    ## con
    poc_con_p6lz = i_poc_intake_daily_p6lzt[..., 0] / 1000 #divide 1000 to convert to tonnes of foo per ha

    ## vol
    ### calc relative quality - note that the equation system used is the one selected for dams in p1 - currently only cs function exists
    if uinp.sheep['i_eqn_used_g1_q1p7'][6,0]==0: #csiro function used
        poc_ri_qual_p6z = fsfun.f_rq_cs(i_poc_dmd_p6zt[..., :, 0], i_legume_zt[..., 0])
    ### adjust foo and calc hf
    i_poc_foo_p6z, hf = fsfun.f_foo_convert(cu3, cu4, i_poc_foo_p6zt[:,:,0], i_pasture_stage_p6zt[...,0], i_legume_zt[...,0]
                                            , i_hr_scalar_zt[...,0], z_pos=-1)
    ### calc relative availability - note that the equation system used is the one selected for dams in p1 - need to hook up mu function
    if uinp.sheep['i_eqn_used_g1_q1p7'][5,0]==0: #csiro function used
        poc_ri_quan_p6z = fsfun.f_ra_cs(i_poc_foo_p6z, hf)
    elif uinp.sheep['i_eqn_used_g1_q1p7'][5,0]==1: #Murdoch function used
        poc_ri_quan_p6z = fsfun.f_ra_mu(i_poc_foo_p6z, hf)

    poc_ri_p6z = fsfun.f_rel_intake(poc_ri_quan_p6z, poc_ri_qual_p6z, i_legume_zt[..., 0])
    poc_vol_p6z = fun.f_divide(1000, poc_ri_p6z)  # 1000 to convert to vol per tonne
    poc_vol_fp6z = poc_vol_p6z * nv_is_not_confinement_f[:,na,na]  # me from pasture is 0 in the confinement pool

    ## md per tonne
    poc_md_p6z = fsfun.f1_dmd_to_md(i_poc_dmd_p6zt[..., 0])
    ##reduce me if nv is higher than livestock diet requirement.
    confinement_inc = np.any(np.logical_not(nv_is_not_confinement_f))
    poc_md_fp6z = fsfun.f_effective_mei(1000, poc_md_p6z, me_threshold_fp6zt[...,0]
                                           , confinement_inc, poc_ri_p6z, i_me_eff_gainlose_p6zt[...,0])
    ###Can't graze poc pasture while in confinement so ME is 0
    poc_md_fp6z = poc_md_fp6z * nv_is_not_confinement_f[:,na,na] #me from pasture is 0 in the confinement pool

    return poc_con_p6lz, poc_md_fp6z, poc_vol_fp6z


def f1_calc_foo_profile(germination_p6lzt, dry_decay_p6zt, length_of_periods_fzt
                        , i_fxg_foo_op6lzt, c_fxg_a_op6lzt, c_fxg_b_op6lzt, i_grn_senesce_eos_p6zt
                        , grn_senesce_startfoo_p6zt, grn_senesce_pgrcons_p6zt):
    '''
    Calculate the FOO level at the start of each feed period from the germination & sam on PGR provided

    Parameters
    ----------
    germination_p6lt     - An array[feed_period,lmu,type] : kg of green feed germinating in the period.
    dry_decay_p6t        - An array[feed_period,type]     : decay rate of dry feed
    length_of_periods_f - An array[feed_period]          : days in each period
    Returns
    -------
    An array[feed_period,lmu,type]: foo at the start of the period.
    '''
    n_feed_periods = len(per.f_feed_periods()) - 1
    n_lmu = np.count_nonzero(pinp.general['i_lmu_area'])
    n_pasture_types = germination_p6lzt.shape[-1]
    n_season = length_of_periods_fzt.shape[-2]
    p6lzt = (n_feed_periods, n_lmu, n_season, n_pasture_types)
    ### reshape the inputs passed and set some initial variables that are required
    grn_foo_start_p6lzt   = np.zeros(p6lzt, dtype = 'float64')
    grn_foo_end_p6lzt     = np.zeros(p6lzt, dtype = 'float64')
    dry_foo_start_p6lzt   = np.zeros(p6lzt, dtype = 'float64')
    dry_foo_end_p6lzt     = np.zeros(p6lzt, dtype = 'float64')
    pgr_daily_lt          = np.zeros((n_lmu, n_pasture_types), dtype=float)  #only required if using the ## loop on lmu. The boolean filter method creates the array

    index_t = np.arange(n_pasture_types)
    ## loop through the feed periods and calculate the foo at the start of each period
    for f in range(n_feed_periods):
        grn_foo_start_p6lzt[f,:,:,:] = germination_p6lzt[f,:,:,:] + grn_foo_end_p6lzt[f-1,:,:,:]
        dry_foo_start_p6lzt[f,:,:,:] = dry_foo_end_p6lzt[f-1,:,:,:]
        ##loop season
        for z in range(n_season):
            ## alternative approach (a1)
            ## for pgr by creating an index using searchsorted (requires an lmu loop). ^ More readable than other but requires pgr_daily matrix to be predefined
            for l in [*range(n_lmu)]: #loop through lmu
                ###find where foo_start fits into the input data
                o_idx_t = fun.searchsort_multiple_dim(i_fxg_foo_op6lzt[:,f,l,z,:], grn_foo_start_p6lzt[f,l,z,:], axis_a0=1, axis_v0=0, side='left')
                pgr_daily_lt[l] = (       c_fxg_a_op6lzt[o_idx_t,f,l,z,index_t] #advanced indexing
                                  +      c_fxg_b_op6lzt[o_idx_t,f,l,z,index_t] #advanced indexing
                                  * grn_foo_start_p6lzt[f,l,z,:])
            grn_foo_end_p6lzt[f,:,z,:] = (              grn_foo_start_p6lzt[f,:,z,:]
                                         * (1 - grn_senesce_startfoo_p6zt[f,z,:])
                                         +                 pgr_daily_lt
                                         *         length_of_periods_fzt[f,z,:]
                                         * (1 -  grn_senesce_pgrcons_p6zt[f,z,:])) \
                                        * (1 -     i_grn_senesce_eos_p6zt[f,z,:])
            senescence_l = grn_foo_start_p6lzt[f,:,z,:]  \
                          +    pgr_daily_lt * length_of_periods_fzt[f,z,:]  \
                          -  grn_foo_end_p6lzt[f,:,z,:]
            dry_foo_end_p6lzt[f,:,z,:] = dry_foo_start_p6lzt[f,:,z,:] \
                                    * (1 - dry_decay_p6zt[f,z,:]) \
                                    + senescence_l
    return grn_foo_start_p6lzt, dry_foo_start_p6lzt

def f1_update_reseeding_foo(foo_grn_reseeding_p6lrzt, foo_dry_reseeding_p6lrzt,
                         resown_rt, period_zt, proportion_zt,
                         foo_arable_zt, foo_na_zt, propn_grn=1): #, dmd_dry=0):
    ''' Adjust p_foo parameters due to changes associated with reseeding: destocking pastures prior to spraying and restocking after reseeding

    period_t     - an array [type] : the first period affected by the destocking or subsequent restocking.
    proportion_t - an array [type] : the proportion of the FOO adjustment that occurs in the first period (the balance of the adjustment occurs in the subsequent period).
    foo_arable   - an array either [lmu] or [lmu,type] : change of FOO on arable area. A negative value if it is a FOO reduction due to destocking or positive if a FOO increase when restocked.
    foo_na       - an array either [lmu] or [lmu,type] : change of FOO on the non arable area.
    propn_grn    - a scalar or an array [type] : proportion of the change in feed available for grazing that is green.
    # dmd_dry      - a scalar or an array [lmu,type] : dmd of dry feed (if any).

    the FOO adjustments is spread between periods to allow for the pasture growth that can occur from the green feed
    and the amount of grazing available if the feed is dry
    If there is an adjustment to the dry feed then it is spread equally between the high & the low quality pools.
    '''
    ##lmu mask
    lmu_mask_l = pinp.general['i_lmu_area'] > 0

    ##base inputs
    n_feed_periods = len(per.f_feed_periods()) - 1
    len_t = np.count_nonzero(pinp.general['pas_inc'])
    n_lmu = np.count_nonzero(pinp.general['i_lmu_area'])
    len_z = period_zt.shape[0]
    len_r = resown_rt.shape[0]
    lzt = (n_lmu,len_z,len_t)
    arable_l = pinp.crop['arable'].squeeze().values[lmu_mask_l]
    ##create arrays
    foo_arable_lzt      = np.zeros(lzt, dtype = 'float64')             # create the array foo_arable_lt with the required shape - needed because different sized arrays are passed in
    foo_arable_lzt[...] = foo_arable_zt                                # broadcast foo_arable into foo_arable_lt (to handle foo_arable not having an lmu axis)
    foo_na_lzt          = np.zeros(lzt, dtype = 'float64')             # create the array foo_na_l with the required shape
    foo_na_lzt[...]     = foo_na_zt                                    # broadcast foo_na into foo_na_l (to handle foo_arable not having an lmu axis)
#    propn_grn_t         = np.ones(len_t, dtype = 'float64')            # create the array propn_grn_t with the required shape
#    propn_grn_t[:]      = propn_grn                                    # broadcast propn_grn into propn_grn_t (to handle propn_grn not having a pasture type axis)

    ### the arable foo allocated to the rotation phases
    foo_arable_lrzt = foo_arable_lzt[:,na,...]  \
                        * arable_l[:,na,na,na] \
                        * resown_rt[:,na,:]
    foo_arable_lrzt[np.isnan(foo_arable_lrzt)] = 0

    foo_na_lrz = np.sum(foo_na_lzt[:, na,:,0:1]
                   * (1-arable_l[:,na,na,na])
                   *    resown_rt[:, na,0:1], axis = -1)
    foo_na_lrz[np.isnan(foo_na_lrz)] = 0
    foo_change_lrzt         = foo_arable_lrzt
    foo_change_lrzt[...,0] += foo_na_lrz  #because all non-arable is pasture 0 (annuals)

    ##allocate into reseeding period - using advanced indexing
    period_lrzt = period_zt[na,na,...]
    next_period_lrzt = (period_lrzt+1) % n_feed_periods
    l_idx=np.arange(n_lmu)[:,na,na,na]
    r_idx=np.arange(len_r)[:,na,na]
    z_idx=np.arange(len_z)[:,na]
    t_idx=np.arange(len_t)
    foo_grn_reseeding_p6lrzt[period_lrzt,l_idx,r_idx,z_idx,t_idx]      = foo_change_lrzt *    proportion_zt  * propn_grn      # add the amount of green for the first period
    foo_grn_reseeding_p6lrzt[next_period_lrzt,l_idx,r_idx,z_idx,t_idx] = foo_change_lrzt * (1-proportion_zt) * propn_grn  # add the remainder to the next period (wrapped if past the 10th period)
    foo_dry_reseeding_p6lrzt[period_lrzt,l_idx,r_idx,z_idx,t_idx]      = foo_change_lrzt *    proportion_zt  * (1-propn_grn) * 0.5  # assume 50% in high & 50% into low pool. for the first period
    foo_dry_reseeding_p6lrzt[next_period_lrzt,l_idx,r_idx,z_idx,t_idx] = foo_change_lrzt * (1-proportion_zt) * (1-propn_grn) * 0.5  # add the remainder to the next period (wrapped if past the 10th period)

    return foo_grn_reseeding_p6lrzt, foo_dry_reseeding_p6lrzt

